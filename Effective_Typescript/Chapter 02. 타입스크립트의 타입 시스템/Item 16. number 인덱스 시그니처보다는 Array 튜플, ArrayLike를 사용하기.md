# Item 16. number 인덱스 시그니처보다는 Array 튜플, ArrayLike를 사용하기
자바스크리브에서 객체란 *키 / 값* 쌍의 모음이며 키는 보통 **문자열**이며 값은 뭐든지 가능하다.  
파이썬이나 자바에서 볼 수 있는 해시 가능 객체라는 표현은 자바스크립트에서는 존재하지 않는다.  
더 복잡한 객체를 키로 사용하기 위해서는 `toString` 메서드가 호출되어 객체가 문자열로 변환되어야 한다.  

#### ⚠️ 숫자는 키로 사용할 수 없다.
속성 이름으로 숫자를 사용하면 자바스크립트 런타임은 **문자열**로 변환한다.  
  
배열의 경우 객체이므로 숫자 인덱스를 사용하는 것이 당연하다.  
하지만 `Object.keys`를 이용해 배열의 키를 나여래 보면 키가 문자열로 출력된다.  

#### 숫자 키와 문자키 구분하기
```typescript
    // ...
    [n: number]: T;
```
런타임에서는 ECMAScrpit 표준이 서술하는 것처럼 문자열 키로 인식하므로 이 코드는 완전히 가상이라고 할 수 있지만, 타입 체크 시점에서 오류를 확인할 수 있어 유용하다.  

```typescript
    const xs = [1, 2, 3];
    const x0 = xs[1];           // Ok
    const x1 = xs['1'];         // 인덱스 식이 'number' 형식이 아니므로
                                // 요소에 암시적으로 'any' 형식이 있습니다.
    function get<T> (array: T[], k: string): T {
        return array[k];
        // 인덱스 식이 'number' 형식이 아니므로
        // 요소에 암시적으로 'any' 형식이 있습니다.
    };
```
위 코드는 실제로 동작하지 않고 타입 정보는 런타임에서 제거 된다.  
`Object.keys`는 문자열로 반환된다.  

```typescript
    const keys = Object.keys(xs);       // 타입이 string[]
    for (const key in xs) {
        key;                            // 타입이 string
        const x = xs[key];              // 타입이 number
    };
```
`string`이 `number`에 할당될 수 없지만 배열을 순회하는 코드 스타일에 대한 실용적인 허용으로 코드가 동작한다.  
  
인덱스에 신경쓰지 않는다면 위의 반복이 아니라 `for-of`를 사용하며,  
인덱스의 타입이 중요하면 `number` 타입을 제공하는 `forEach`를 사용해야 한다.  
> 타입이 불확실하다면 `for-in` 루프는 `for-of` 또는 C 스타일의 `for` 루프보다 몇 배 느리다.
  
인덱스 시그니처가 `number`로 표현되어 있다면 입력한 값이 `number`여야 한다는 것을 의미하지만 (`for-in`루프 제외),  
일반적으로 `string` 대신 `number`를 타입의 인덱스로 사용해야 하는 이유는 많지 않다.  
  
만약 **숫자**를 사용하여 인덱스할 항목을 지정한다면 **Array** 또는 **튜플** 타입을 대신 사용하게 될 것 이다.  
`number`를 인덱스 타입으로 사용하면 숫자 속성이 어떤 특별한 의미를 가진다는 오해를 할 수 있다.  
  
어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트의 `ArrayLike` 타입을 사용한다.  
#### 단, ArrayLike를 사용하더라도 키는 여전히 문자열이다.
  
## 📝 요약
- 배열은 객체이므로 키는 숫자가 아니라 **문자열**이다.
  - 인덱스 시그니처로 사용된 `number` 타입은 버그를 잡기 위한 순수한 타입스크립트 코드이다.
- 인덱스 시그니처에 `number`를 사용하기보다 **Array나 튜플, 또는 ArrayLike 타입**을 사용하는 것이 좋다.