# Item 03. 코드 생성과 타입이 관계없음을 이해하기
타입스크립틔 컴파일러는 두 가지 역할을 수행한다.
1. 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스 파일한다.<br>
2. 코드의 <b>타입 오류</b>를 체크한다<br>
> 트랜스파일<br>
> translate + complie로, 소스코드를 동일한 동작을 하는 다른 소스코드 (다른 버전, 언어 등)로 변환하는 행위를 의미한다.<br>
> 결과물이 여전히 컴파일 되어야 하는 소스코드이기 때문에 컴파일과는 구분해서 부른다.<br>
<br>

여기서 이 두 가지는 서로 완벽히 ⭐ <b>독립적</b> ⭐ 이다.<br>
타입스크립트가 자바스크립트로 변환될 때, 코드 내 타입에는 영향을 주지 않으며 실행 시점에도 타입은 영향을 주지 않는다.<br>

## ✔ 타입 오류가 있는 코드도 컴파일이 가능하다.
컴파일은 <b>타입 체크와 독립적</b>으로 동작하기 때문에 타입 오류가 있는 코드도 컴파일이 가능하다.<br>
타입 체크와 컴파일이 동시에 이뤄지는 C나 자바와 같은 언어와 달리 문제가 될만한 부문을 경고로 알려주지만 그렇다고 빌드를 멈추지는 않는다.<br>
<br>
만약 오류가 있을 때 컴파일 하지 않으려면 `tsconfig.json`에 `noEmitOnError`를 설정하거나 빌드 도구에 동일하게 적용하면 된다.<br>

## ✔ 타입 연산은 런타임에 영향을 주지 않는다.
타입스크립트는 일반적으로 실행되지 못하는 죽은 코드를 찾아내지만, `strict`를 설정해도 찾아내지 못한다.<br>
`:boolean`이 타입 선언문이라는 것에 주목해야 한다.<br>
타입스크립트의 타입이기에 `:boolean`은 런타임에 제거된다.<br>
타입 스크립트에서는 런타입 타입과 선언된 타입이 맞지 않을 수도 있다.<br>
타입이 달라지는 혼란스러운 상황을 가능한 한 피해야 한다.<br>
선언된 타입이 <b>언제든지 달라질 수 있다는 것</b>을 명심‼<br>

## ✔ 타입스크립트 타입으로는 함수를 오버로드 할 수 없다.
C++과 같은 언어는 동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용한다.<br>
이를 <b>함수 오버로딩</b> 이라고 한다.<br>
그러나 타입스크립트에서는 타입과 런타임의 동작이 무관하므로 함수 오버로딩은 불가하다.<br>
지원은 하지만 온전히 타입 수준에서만 동작한다.<br>
하나의 함수에 대해서 여러 개의 선언문을 작성할 수 있지만 <b>구현체(implementation)는 오직 하나</b> 뿐 이다.<br>