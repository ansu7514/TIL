# Flux 패턴
## ♾️ Flux 출현 배경
#### 기존 MVC 모델의 한계
기존 어플리케이션 환경에서 보편적으로 사용되는 패턴은 **MVC**였다.<br>
<br>
Model에 데이터를 정의하고, Controller를 이용해 Model 데이터를 생성, 조회, 수정, 삭제하고, 변경된 데이터는 View에 출력되면서 사용자에게 전달되었다.<br>
<br>
![MVC_Pattern](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbE2dLD%2FbtrE3GPOmDr%2FKck8GaVaLYslnKtp3mKLpK%2Fimg.png)
<br>
<br>
이 패턴의 문제점은 어플리케이션의 규모가 커질 수록 데이터 흐름의 복잡도가 증가한다는 것이다.<br>
<br>
MVC 패턴은 데이터의 변경사항을 신속하게 전파하기 어려운데, 모델이 증가할 수록 전파할 대상이 함께 증가하기 때문이다. 하나의 포스트가 삭제될 경우, 포스트에 달려있는 댓글도 함께 삭제되어야 하는데, 이때 댓글이 사라진 각 유저의 댓글 사이드바나 사이트 헤더의 전체 댓글 카운터에도 변경사항이 전달되어야 한다.
MVC 패턴에서는 사이드바와 헤더의 데이터를 관리하는 모델들이 포스트 모델을 항상 주시하게 만들게 될 것이고, 코드는 더 복잡해질 것이다.<br>
<br>
<br>

## 🤔 Flux 패턴 살펴보기
facebook은 이러한 문제를 해결하기 위해서 **Flux**라는 패턴을 만들었다.<br>
Model이 View를 반영하고, View가 Model을 변경하는 양방향 데이터 흐름에서 벗어나 단방향으로만 데이터를 변경할 수 있도록 했다.<br>
<br>
![Flux_Pattern](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Feh7cBn%2FbtrE4mDkwKm%2F5Cc1XorHqYR8GIVqks5HgK%2Fimg.png)
<br>

#### Action / Action Creator
액션은 데이터의 상태를 변경할 수 있는 명령어 카드와 같다.<br>
액션 생성자는 새로 발생한 액션의 타입과 데이터 페이로드를 액션 메시지로 묶어 디스패쳐로 전달한다.<br>

#### Dispatcher
디스패쳐는 액션 메시지를 감지하는 순간 그것을 각 스토어에 전달한다. 전달은 콜백 함수로 이루어지며, 등록되어 있는 모든 스토어로 페이로드를 전달할 수 있다.<br>
이때 스토어가 서로를 의존하고 있다면 특정 스토어가 업데이트 되기를 기다리게 해주는 `waitFor()`를 사용할 수 있다.
 
#### Store (Model)
스토어는 어플리케이션의 상태와, 상태를 변경할 수 있는 메서드를 가지고 있다.<br>
어떤 타입의 액션이 날라왔느냐에 따라 메서드를 다르게 적용해 상태를 변경하게 된다.
 
#### View
React에 해당되는 부분이다.<br>
컨트롤러 뷰는 스토어에서 변경된 데이터를 가져와 모든 자식 뷰에게 데이터를 분배한다. 데이터를 넘겨받은 뷰는 화면을 새로 렌더링한다.<br>
<br>
<br>

## ⁉️ 그래서 결과는...
- 선생님이 뷰를 통해 A군의 수학 점수를 입력한다.
- 뷰는 데이터를 업데이트하기 위해 액션 생성자를 호출한다.
- 액션 생성자는 수학 점수를 업데이트하기 위한 액션 타입과 입력된 값을 묶어 디스패쳐로 전달한다.
  - ex) `actionType: 'UPDATE_MATH', payload: ['A', '75'])`
- 액션 메시지를 감지한 디스패쳐는 액션을 matchStore와 studentStore에 전달한다.
- 각 스토어는 액션 타입에 따라 상태를 변경한다. 만일 studentStore가 mathStore를 의존하고 있다면, 콜백 체인을 통해 mathStore가 먼저 업데이트 되기를 기다렸다가 studentStore를 업데이트할 수 있다.
- 스토어가 업데이트를 마치면 이를 감지한 컨트롤러 뷰가 자식 뷰에게 새로운 값을 분배한다.
- 마지막으로 뷰는 새로운 값으로 화면을 렌더링한다.
<br>
데이터 흐름은 한 방향으로 강제되고, 모든 상태는 스토어에 모여 있으므로 변경 사항을 여러 컴포넌트로 전달하기도 쉬워졌다.<br>
<br>
<br>

## ‼️ Flux != Redux
오늘날에는 **Redux**가 상태 매니저로 널리 사용되고 있지만, 최근엔 Redux가 기능에 비해 너무 과한 타이핑을 요구한다는 불만이 제기되고 있다. 많은 개발자들이 Redux를 대체할 더 간단한 솔루션을 찾고 있고, React도 이런 요구에 발맞추기 위해 16.3버전부터 Context API를 제공하고 있다.<br>
<br>
그런데 왜 원조 격인 Flux 대신 Redux가 더 흥했던 것일까? 그리고 왜 Flux 컨셉을 따르고 있는데도 사람들은 왜 Redux를 벗어나려고 할까?<br>
<br>
Redux가 널리 쓰인 이유는 단순하다.<br>
Flux 패키지는 실제 프로젝트에 적용하도록 만들어졌기보단 Flux 패턴 컨셉을 시연한 수준이였고, Redux는 이 패턴을 적용한 프로젝트였기 때문이다.<br>
<br>
Redux가 모두에게 만족스럽지 않은 이유는 복잡하다<br>
<br>
우선 **Redux는 Flux 패턴을 그대로 구현하지 않았다**. Flux  패턴과 함수형 프로그래밍, 불변 데이터 컨셉을 적절히 버무려서 제작되었다.<br>
<br>
**Redux에는 디스패쳐 개념이 없다**. 간단히 말해서 "리듀서"가 "디스패쳐 + 스토어"의 기능을 담당한다. (Redux의 스토어는 어플리케이션의 유일 객체로서 뷰 전체를 Wrapping하는 역할만 맡는다.) 이벤트 에미터로 작동하는 디스패쳐를 생략하고 리듀서가 각 애션 타입에 대한 메서드를 순수함수로 구현하는 편이 낫다는 입장이다. 여기서 한 걸음 나아가 Redux는 리듀서가 관리하는 모든 상태를 immutable하도록 설정한다. 업데이트 된 값은 기존의 상태에 overwirte되는 것이 아니라 새로운 객체로 복사되어 리턴된다. **각 리듀서는 서로를 의존할 수 없고 완전히 고립되어 있다**.<br>
<br>
두번째로 **Redux의 스토어는 싱글턴 패턴을 따른다**. Flux의 스토어가 각자의 상태만 간직한 채 여럿으로 공존했던 것과 달리, Redux는 상태를 지니는 역할을 리듀서로 넘긴 뒤 모든 종류의 리듀서가 단 하나의 스토어에 묶이도록 설계했다. 각 뷰가 자신이 필요한 스토어만 각각 접근할 수 있었던 Flux와 달리 Redux는 무조건 싱글 스토어를 통해 각 리듀서에 접근할 수 있다.<br>
<br>
불변 데이터 컨셉으로 무결성을 보장하고 side-effect 없이 상태를 업데이트하도록 강제한 것은 분명 Redux의 장점이다. 하지만 이를 위해 디스패쳐를 이용한 유연한 업데이트 방식을 포기하고, 중앙집중형 스토어를 구현함으로써 뷰가 데이터에 접근하는 방식을 무척 번거롭게 만들었는 것도 사실이다.